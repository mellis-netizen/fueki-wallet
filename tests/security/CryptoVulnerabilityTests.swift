import XCTest
@testable import FuekiWallet

/// Security tests for common cryptographic vulnerabilities
/// Tests against known attack vectors and cryptographic weaknesses
class CryptoVulnerabilityTests: XCTestCase {

    var cryptoService: CryptoService!

    override func setUp() {
        super.setUp()
        cryptoService = CryptoService()
    }

    override func tearDown() {
        cryptoService = nil
        super.tearDown()
    }

    // MARK: - Timing Attack Tests

    func testConstantTimeComparison() {
        // Arrange
        let secret1 = Data([0x12, 0x34, 0x56, 0x78])
        let secret2 = Data([0x12, 0x34, 0x56, 0x78])
        let wrong = Data([0xFF, 0x34, 0x56, 0x78])

        // Act - Measure timing
        let start1 = Date()
        let match = cryptoService.constantTimeCompare(secret1, secret2)
        let time1 = Date().timeIntervalSince(start1)

        let start2 = Date()
        let noMatch = cryptoService.constantTimeCompare(secret1, wrong)
        let time2 = Date().timeIntervalSince(start2)

        // Assert
        XCTAssertTrue(match)
        XCTAssertFalse(noMatch)

        // Timing should be similar (within 50% margin)
        let timeDiff = abs(time1 - time2)
        let avgTime = (time1 + time2) / 2
        XCTAssertLessThan(timeDiff, avgTime * 0.5, "Timing difference suggests timing attack vulnerability")
    }

    func testSignatureVerificationTimingResistance() throws {
        // Arrange
        let keyPair = try cryptoService.generateEd25519KeyPair()
        let message = "Test message".data(using: .utf8)!
        let validSignature = try cryptoService.sign(message, with: keyPair.privateKey)

        var invalidSignature = validSignature
        invalidSignature[0] ^= 0x01

        // Act - Measure verification time
        let start1 = Date()
        _ = try cryptoService.verify(validSignature, for: message, publicKey: keyPair.publicKey)
        let validTime = Date().timeIntervalSince(start1)

        let start2 = Date()
        _ = try cryptoService.verify(invalidSignature, for: message, publicKey: keyPair.publicKey)
        let invalidTime = Date().timeIntervalSince(start2)

        // Assert - Times should be similar
        let timeDiff = abs(validTime - invalidTime)
        let avgTime = (validTime + invalidTime) / 2
        XCTAssertLessThan(timeDiff, avgTime * 0.5, "Verification timing should not leak validity")
    }

    // MARK: - Weak Key Tests

    func testRejectWeakPrivateKeys() {
        // Test weak keys (all zeros, all ones, etc.)
        let weakKeys = [
            Data(repeating: 0x00, count: 32),
            Data(repeating: 0xFF, count: 32),
            Data(repeating: 0x01, count: 32),
        ]

        for weakKey in weakKeys {
            XCTAssertFalse(cryptoService.isValidPrivateKey(weakKey), "Weak key should be rejected")
        }
    }

    func testRejectSmallPrivateKeys() {
        // Test keys with small values
        var smallKey = Data(repeating: 0x00, count: 32)
        smallKey[31] = 0x01 // Key value = 1

        XCTAssertFalse(cryptoService.isValidPrivateKey(smallKey), "Small key should be rejected")
    }

    func testRejectLargePrivateKeys() {
        // Test keys larger than curve order
        // For secp256k1, order = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
        let largeKey = Data(repeating: 0xFF, count: 32)

        XCTAssertFalse(cryptoService.isValidPrivateKey(largeKey, curve: .secp256k1), "Key larger than curve order should be rejected")
    }

    // MARK: - Nonce Reuse Tests

    func testNonceReusePrevention() throws {
        // Arrange - ECDSA signature nonce reuse is catastrophic
        let keyPair = try cryptoService.generateSecp256k1KeyPair()
        let message1 = "Message 1".data(using: .utf8)!
        let message2 = "Message 2".data(using: .utf8)!

        // Act - Sign same message twice
        let sig1 = try cryptoService.signSecp256k1Deterministic(cryptoService.sha256(message1), with: keyPair.privateKey)
        let sig2 = try cryptoService.signSecp256k1Deterministic(cryptoService.sha256(message1), with: keyPair.privateKey)

        // Assert - Signatures should be identical (RFC 6979 deterministic)
        XCTAssertEqual(sig1, sig2, "Deterministic signatures should be identical")

        // Sign different messages
        let sig3 = try cryptoService.signSecp256k1Deterministic(cryptoService.sha256(message2), with: keyPair.privateKey)
        XCTAssertNotEqual(sig1, sig3, "Different messages should have different signatures")
    }

    // MARK: - Padding Oracle Tests

    func testPaddingOracleResistance() throws {
        // Test encryption/decryption doesn't leak padding information
        let plaintext = "Test data with specific length".data(using: .utf8)!
        let password = "encryption-password"

        // Act - Encrypt
        let ciphertext = try cryptoService.encrypt(plaintext, password: password)

        // Tamper with padding
        var tamperedCiphertext = ciphertext
        tamperedCiphertext[tamperedCiphertext.count - 1] ^= 0x01

        // Assert - Decryption should fail cleanly without leaking info
        do {
            _ = try cryptoService.decrypt(tamperedCiphertext, password: password)
            XCTFail("Should throw error on tampered ciphertext")
        } catch {
            XCTAssertTrue(error is CryptoError)
            // Error message should not reveal padding details
            let errorDescription = (error as? CryptoError)?.localizedDescription ?? ""
            XCTAssertFalse(errorDescription.contains("padding"), "Error should not mention padding")
        }
    }

    // MARK: - Length Extension Attack Tests

    func testHashingLengthExtensionResistance() {
        // Use HMAC or SHA-3 which are resistant to length extension
        let message = "Original message".data(using: .utf8)!
        let key = "secret-key".data(using: .utf8)!

        // Act - Use HMAC-SHA256 (resistant)
        let hmac = cryptoService.hmacSHA256(message, key: key)

        // Attempting length extension should fail
        let extension = "Extension data".data(using: .utf8)!
        let extendedMessage = message + extension

        let extendedHmac = cryptoService.hmacSHA256(extendedMessage, key: key)

        // Assert - HMAC should be completely different
        XCTAssertNotEqual(hmac, extendedHmac)
    }

    // MARK: - Random Number Generator Tests

    func testRandomNumberQuality() {
        // Generate multiple random values and test distribution
        var randoms: [Data] = []
        for _ in 0..<100 {
            let random = cryptoService.generateRandomBytes(32)
            randoms.append(random)
        }

        // Test 1: All values should be unique
        let uniqueCount = Set(randoms).count
        XCTAssertEqual(uniqueCount, 100, "All random values should be unique")

        // Test 2: Bit distribution should be roughly 50/50
        var oneBits = 0
        var totalBits = 0
        for random in randoms {
            for byte in random {
                for bit in 0..<8 {
                    if (byte >> bit) & 1 == 1 {
                        oneBits += 1
                    }
                    totalBits += 1
                }
            }
        }

        let ratio = Double(oneBits) / Double(totalBits)
        XCTAssertGreaterThan(ratio, 0.48, "Bit distribution should be close to 50%")
        XCTAssertLessThan(ratio, 0.52, "Bit distribution should be close to 50%")
    }

    func testRandomNumberNoPredictability() {
        // Generate sequence and test for patterns
        var values: [UInt8] = []
        for _ in 0..<1000 {
            let random = cryptoService.generateRandomBytes(1)
            values.append(random[0])
        }

        // Test for sequential patterns
        var sequentialCount = 0
        for i in 0..<(values.count - 1) {
            if values[i] + 1 == values[i + 1] {
                sequentialCount += 1
            }
        }

        // Less than 5% should be sequential
        let sequentialRatio = Double(sequentialCount) / Double(values.count)
        XCTAssertLessThan(sequentialRatio, 0.05, "Should not have sequential patterns")
    }

    // MARK: - Key Derivation Tests

    func testPBKDF2Iterations() {
        // Ensure sufficient iterations for password-based key derivation
        let password = "user-password"
        let salt = cryptoService.generateRandomBytes(16)

        // Act
        let derivedKey = cryptoService.pbkdf2(password: password, salt: salt, iterations: 100_000)

        // Assert
        XCTAssertNotNil(derivedKey)
        XCTAssertEqual(derivedKey.count, 32)

        // Verify it takes reasonable time (not too fast = insecure)
        let start = Date()
        _ = cryptoService.pbkdf2(password: password, salt: salt, iterations: 100_000)
        let duration = Date().timeIntervalSince(start)

        XCTAssertGreaterThan(duration, 0.01, "Key derivation should take meaningful time")
    }

    func testKeyDerivationUniqueness() {
        // Different salts should produce different keys
        let password = "user-password"
        let salt1 = cryptoService.generateRandomBytes(16)
        let salt2 = cryptoService.generateRandomBytes(16)

        let key1 = cryptoService.pbkdf2(password: password, salt: salt1, iterations: 10_000)
        let key2 = cryptoService.pbkdf2(password: password, salt: salt2, iterations: 10_000)

        XCTAssertNotEqual(key1, key2, "Different salts should produce different keys")
    }

    // MARK: - Side Channel Attack Tests

    func testCacheTimingResistance() {
        // Test that key operations don't leak info via cache timing
        let keyPair = try! cryptoService.generateEd25519KeyPair()
        let message = "Test message".data(using: .utf8)!

        // Warm up cache
        for _ in 0..<100 {
            _ = try? cryptoService.sign(message, with: keyPair.privateKey)
        }

        // Measure timing for different keys
        var times: [TimeInterval] = []
        for _ in 0..<50 {
            let start = Date()
            _ = try? cryptoService.sign(message, with: keyPair.privateKey)
            times.append(Date().timeIntervalSince(start))
        }

        // Assert - Timing variance should be minimal
        let avgTime = times.reduce(0, +) / Double(times.count)
        let variance = times.map { pow($0 - avgTime, 2) }.reduce(0, +) / Double(times.count)
        let stdDev = sqrt(variance)

        XCTAssertLessThan(stdDev, avgTime * 0.2, "High timing variance suggests side channel leak")
    }

    // MARK: - Replay Attack Tests

    func testTransactionReplayProtection() throws {
        // Arrange
        let transaction = Transaction(
            from: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
            to: "0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed",
            amount: 1_000_000,
            nonce: 5,
            chainId: 1
        )

        // Act - Sign transaction
        let keyPair = try cryptoService.generateSecp256k1KeyPair()
        let transactionService = TransactionService()
        let signedTx = try transactionService.sign(transaction, with: keyPair.privateKey)

        // Assert - Chain ID should be included in signature (EIP-155)
        XCTAssertNotNil(signedTx.chainId)
        XCTAssertEqual(signedTx.chainId, 1)

        // Signature should not be valid on different chain
        var differentChainTx = transaction
        differentChainTx.chainId = 137 // Polygon
        let differentChainSigned = try transactionService.sign(differentChainTx, with: keyPair.privateKey)

        XCTAssertNotEqual(signedTx.signature, differentChainSigned.signature, "Signature should differ by chain")
    }

    // MARK: - Malleability Tests

    func testSignatureMalleability() throws {
        // Test that signatures are in canonical form (not malleable)
        let keyPair = try cryptoService.generateSecp256k1KeyPair()
        let message = "Test message".data(using: .utf8)!
        let messageHash = cryptoService.sha256(message)

        // Act
        let signature = try cryptoService.signSecp256k1(messageHash, with: keyPair.privateKey)

        // Assert - Signature should be in canonical form
        // For ECDSA, s value should be <= curve_order/2
        let isCanonical = cryptoService.isCanonicalSignature(signature)
        XCTAssertTrue(isCanonical, "Signature should be in canonical form to prevent malleability")
    }

    // MARK: - Cryptographic Downgrade Tests

    func testRejectWeakAlgorithms() {
        // Ensure system doesn't accept weak algorithms
        XCTAssertFalse(cryptoService.isAlgorithmSupported(.md5), "MD5 should not be supported")
        XCTAssertFalse(cryptoService.isAlgorithmSupported(.sha1), "SHA1 should not be supported")
        XCTAssertFalse(cryptoService.isAlgorithmSupported(.des), "DES should not be supported")
        XCTAssertFalse(cryptoService.isAlgorithmSupported(.rc4), "RC4 should not be supported")

        // Strong algorithms should be supported
        XCTAssertTrue(cryptoService.isAlgorithmSupported(.sha256))
        XCTAssertTrue(cryptoService.isAlgorithmSupported(.aes256))
        XCTAssertTrue(cryptoService.isAlgorithmSupported(.ed25519))
    }

    // MARK: - Key Exposure Tests

    func testKeyNotInMemoryAfterUse() throws {
        // Arrange
        var keyPair = try cryptoService.generateEd25519KeyPair()
        let privateKeyId = ObjectIdentifier(keyPair.privateKey as AnyObject)

        // Act - Use key
        let message = "Test".data(using: .utf8)!
        _ = try cryptoService.sign(message, with: keyPair.privateKey)

        // Clear key
        cryptoService.secureZeroize(&keyPair.privateKey)

        // Assert - Key should be zeroed
        XCTAssertTrue(keyPair.privateKey.allSatisfy { $0 == 0 })
    }
}
